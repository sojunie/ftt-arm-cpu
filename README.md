# MCU (Microcontroller Unit)

This module implements a minimal MCU in Verilog, designed to execute binary programs generated by our assembler. It includes core hardware components such as the CPU, memory, and optional UART controller.

## Architecture Overview

The MCU is composed of the following subsystems:

- **CPU** – A simple, non-pipelined processor that fetches, decodes and executes instructions
- **Memory** – On-chip RAM, SRAM/BRAM abstraction, and Flash memory
- **UART Controller** – A standalone UART module for serial communication (not yet integrated)
- **Boot ROM** – Loads and runs `bootrom.bin.txt` on startup

```
        +-------------------+
        |    Boot ROM       |
        +-------------------+
                  |
        +-------------------+
        |      CPU          |
        | (no pipeline)     |
        +-------------------+
         |   |   |   |   |     (memory controller & decoder)
         v   v   v   v   v
   +--------+  +--------+  +--------------+
   | SRAM   |  | Flash  |  | Peripherals  |
   +--------+  +--------+  +--------------+
```

## Directory Structure

```bash
mcu/
├── bootloader/              # (Reserved for future bootloader logic)
├── cpu/
│   ├── testbench/           # cocotb-based testbenches
│   ├── verilog/             # Core CPU modules (ALU, decoder, register files)
│   └── README.md
├── memory/
│   ├── testbench/
│   ├── verilog/             # RAM, Flash, address decoder, etc.
│   └── README.md
├── uart-controller/         # UART module (not yet connected to MCU)
│   └── README.md
├── bootrom.s                # Assembly source for boot ROM
├── bootrom.bin.txt          # Boot ROM binary file (loaded by the MCU)
├── mcu.v                    # Top-level Verilog module
├── Makefile                 # Build and simulation commands
└── README.md                # This file
```

## Design Philosophy

- **Minimalism First**: All modules are designed to be simple and readable.
- **No Pipeline (yet)**: The CPU is currently non-pipelined for ease of understanding.
- **Module Separation**: Each subsystem (CPU, memory, UART) is implemented and tested independently.
- **Extendable**: The architecture is modular and will support peripherals and pipelining in future versions.

## Testing Strategy

### Testbenches

We use [`cocotb`](https://github.com/cocotb/cocotb) for writing testbenches in Python. Each major module (`ALU`, `barrel shifter`, `CPU core`, etc.) has its own testbench in:

```bash
cpu/testbench/
memory/testbench/
uart-controller/testbench/
```

Example files:
- `tb_alu.py`
- `tb_barrel_shifter.py`
- `tb_cpu.py`

### Simulation

Simulations are executed using `make` or `simulate.sh`:

```bash
$ cd cpu
$ make       # Runs cocotb test
$ ./simulate.sh  # (Optional wrapper)
```

###  Waveform Debugging

- We use `gtkwave` to debug simulation output (dumped VCD).
- All signals are grouped by module for easy tracing.

```bash
gtkwave dump.vcd
```